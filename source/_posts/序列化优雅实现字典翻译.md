---
title: 序列化优雅实现字典翻译
date: 2023-09-22 13:52:21
tags: 
    - 序列化
    - 方案设计
description: Aop 实现日志功能 ## 页面描述
keywords: aop  ## 关键字
comments: true  ## 评论模块
cover: /top_img/序列化优雅实现字典翻译top_img.jpeg  ## 文章缩略图
# top_img:  ## 顶部图片
aside: false  ## 显示侧边栏（默认 true）
---

#### 序列化优雅实现字典翻译
> 思路：
> 创建自定义注解@My Dic t,通过ContextS e rizal e来解决List、Page类型的字典翻译实现ContextualSerializer接口可以方便的获取注解字段及注解的参数方便序列化的时候拿到想要的参数

1. 自定义一个注解 @MyDict
```
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@JacksonAnnotationsInside
// 自定义序列化 根据提供的序列化类里面的重写方法实现自定义序列化
@JsonSerialize(using = DictSerializer.class)
public @interface MyDict {
    /**
     * 方法描述:  数据code
     */
    String dicCode();

    /**
     * 方法描述:  数据Text
     */
    String dicText() default "";

    /**
     * 方法描述: 数据字典表
     */
    String dictTable() default "";

}
```

* (重点:实现Contextual Serialize r接来便捷的获取到自定义注解的参数，方便后续的字典值转换)使用了Guava Cache的缓存https:/www.bael dung.com/guava-cache
```

@Slf4j
@Component
public class DictSerializer extends StdSerializer<Object> implements ContextualSerializer {

    /**
     * 查询mapper 用来对对字典的查询
     */
    private static SysDictMapper sysDictMapper;
    @Autowired
    public void setUserServer(SysDictMapper sysDictMapper) {
        DictSerializer.sysDictMapper = sysDictMapper;
    }


    /**
     * 字典参数
     */
    @Getter
    @Setter
    private transient String dictTable;
    @Getter
    @Setter
    private transient String dictCode;
    @Getter
    @Setter
    private transient String dictText;

    /**
     * 字典翻译文本后缀
     */
    public static final String DICT_TEXT_SUFFIX = "_dictText";


    protected DictSerializer() {
        super(Object.class);
    }

    @Override
    public JsonSerializer<?> createContextual(SerializerProvider serializerProvider, BeanProperty beanProperty) throws JsonMappingException {
        MyDict myDict = beanProperty.getAnnotation(MyDict.class);
        return createContextual(myDict.dictTable(), myDict.dicCode(), myDict.dicText());
    }

    private JsonSerializer<?> createContextual(String dictTable, String dicCode, String dictText) {
        DictSerializer serializer = new DictSerializer();
        serializer.setDictTable(dictTable);
        serializer.setDictCode(dicCode);
        serializer.setDictText(dictText);
        return serializer;
    }

    @Override
    public void serialize(Object value, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
        try {
            // 考虑到存在字典表，用表名做一个简单的隔离
            Map<String, String> cachMap = DICTIONARY_CACHE.get(getDictTable());

            // 先查缓存 没有就查数据库存到缓存中，后续从缓存中读取
            if (MapUtils.isEmpty(cachMap)) {
                Map<String, String> textMap = translateDict(getDictTable(), getDictText(), getDictCode());
                DICTIONARY_CACHE.put(getDictTable(), textMap);
                cachMap.putAll(textMap);
            }

            // 添加 字典翻译字段
            String label = cachMap.get(value.toString());
            jsonGenerator.writeObject(value);
            // 在需要转换的字段上添加@Dict注解，注明需要引用的code，后端会在返回值中增加filedName_dictText的key，前端只需要取对应的 filedName_dictText 就可以直接使用
            jsonGenerator.writeFieldName(jsonGenerator.getOutputContext().getCurrentName() + DICT_TEXT_SUFFIX);
            jsonGenerator.writeObject(label);

        } catch (ExecutionException e) {
            log.error("字典转换异常:",e.getMessage());
            throw new RuntimeException(e);
        }
    }


    /**
     * 使用谷歌Guava 做本地缓存
     */
    public static final LoadingCache<String, Map<String, String>> DICTIONARY_CACHE = CacheBuilder.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(30, TimeUnit.SECONDS)
            .expireAfterAccess(10, TimeUnit.SECONDS)
            .build(new CacheLoader<String, Map<String, String>>() {
                @Override
                public Map<String, String> load(String key) {
                    Map<String, String> map = new HashMap<>();
                    return map;
                }
            });


    /**
     * 翻译字典 使用 sql 查询数据表的方式获取text
     */
    public Map<String, String> translateDict(String table, String text, String code) {
        // 通过拼接sql 查询 字典值
        List<DictModel> dictModels = null;
        if (StringUtils.isEmpty(getDictTable())){
            dictModels = sysDictMapper.queryEnableDictItemsByCode(code);
        }else{
            dictModels = sysDictMapper.queryTableDictItemsByCode(table, text, code);
        }
        // 将 list 转换为 map 方便后续的字典获取
        return dictModels.stream().collect(Collectors.toMap(DictModel::getValue, DictModel::getText, (value1, value2) -> value1));
    }
}
```

* 创建 mapper
```
   /**
 * 查询有效的数据字典项
 * @param code
 * @return
 */
List<DictModel> queryEnableDictItemsByCode(@Param("code") String code);
   

   /**
 * 查询数据字典表 (自己创建的字典表)
 * @param code
 * @return
 */
public List<DictModel> queryTableDictItemsByCode(@Param("table") String table,@Param("text") String text,@Param("code") String code);
```

* mapper.xml
```
   <!-- 通过字典code获取有效的字典数据项 -->
<select id="queryEnableDictItemsByCode" parameterType="String"  resultType="org.jeecg.common.system.vo.DictModel">
	   select s.item_value as "value",s.item_text as "text" from sys_dict_item s
	   where dict_id = (select id from sys_dict where dict_code = #{code})
	   and s.status = 1
	   order by s.sort_order asc
</select>

   <!--通过查询指定table的 text code 获取字典-->
<select id="queryTableDictItemsByCode" parameterType="String"  resultType="org.jeecg.common.system.vo.DictModel">
	   select ${text} as "text",${code} as "value" from ${table}
</select>
```

* 使用自定义注解
```
/**出库类型*/
@Excel(name = "出库类型", width = 15, dicCode = "outWarehouseType")
   @ApiModelProperty(value = "出库类型")
   @MyDict(dicCode = "outWarehouseType")
   private java.lang.String outType;
```

* 测试
```
@RequestMapping(value = "/test", method = RequestMethod.POST)
@ApiOperation(value="字典翻译测试", notes="字典翻译测试")
public Result<?> importExcel(@RequestParam(name="pageNo", defaultValue="1") Integer pageNo,
                            @RequestParam(name="pageSize", defaultValue="10") Integer pageSize) throws JsonProcessingException {
Page<WarehouseOutCertificate> pageTest = warehouseOutCertificateService.page(new Page<WarehouseOutCertificate>(pageNo, pageSize));

ObjectMapper mapper = new ObjectMapper();
String s = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(pageTest);
log.info("测试字典翻译:"+s);

return Result.OK(pageTest);
}
```

* 测试数据
![图片](http://img.11001001.cn/201_blog/%E5%BA%8F%E5%88%97%E5%8C%96%E7%BF%BB%E8%AF%91%E6%B5%8B%E8%AF%95.png)