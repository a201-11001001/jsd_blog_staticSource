---
title: 保证接口数据安全
date: 2023-09-08 21:17:51
tags: 
    - 数据加密
    - 方案设计
description: 用jdk 自带加密工具实现对接口数据传输的加密 ## 页面描述
keywords: 加密  ## 关键字
comments: true  ## 评论模块
cover: /top_img/保证数据接口安全top_img.jpeg ## 文章缩略图
# top_img:  ## 顶部图片
aside: false  ## 显示侧边栏（默认 true）
---

#### Jdk 实现数据加密

> 业务需求: 主系统开放接口 => 子系统给主系统推送结算数据 => 主系统用推送的结算数据设计报表

对称加密（Des，Triple Des，AES）
采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。常用的单向加密算法：

* DES（Data Encryption Standard）：数据加密标准，速度较快，适用于加密大量数据的场合；
* 3DES（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高；
* AES（Advanced Encryption Standard）：高级加密标准，是下一代的加密算法标准，速度快，安全级别高，支持128、192、256位密钥的加密；

> 导入 bcprov 包
``` 
<dependency>
    <groupId>org.bouncycastle</groupId>
    <artifactId>bcprov-jdk15on</artifactId>
    <version>1.70</version>
</dependency>
```

##### 对称加密的简单实现
```
public class Test {
    public static void main(String[] args) {
        String text = "你好世界！！";

        String key = "12345678";//des必须8字节
        // 算法/模式/填充  默认 DES/ECB/PKCS5Padding
        String transformation = "DES";

        String key1 = "1234567812345678";//aes必须16字节
        String transformation1 = "AES";

        String key2 = "123456781234567812345678";//TripleDES使用24字节的key
        String transformation2 = "TripleDes";

        String extracted = extracted(text, key, transformation, true);
        System.out.println("DES加密：" + extracted);
        String extracted1 = extracted(extracted, key, transformation, false);
        System.out.println("解密：" + extracted1);


        String extracted2 = extracted(text, key1, transformation1, true);
        System.out.println("AES加密：" + extracted2);
        String extracted3 = extracted(extracted2, key1, transformation1, false);
        System.out.println("解密：" + extracted3);

        String extracted4 = extracted(text, key2, transformation2, true);
        System.out.println("Triple Des加密：" + extracted4);
        String extracted5 = extracted(extracted, key2, transformation2, false);
        System.out.println("解密：" + extracted5);

    }

    /**
     * @param text           明文/base64密文
     * @param key            密钥
     * @param transformation 转换方式
     * @param mode           加密/解密
     */
    private static String extracted(String text, String key, String transformation, boolean mode){
        Cipher cipher = null;
        try {
            cipher = Cipher.getInstance(transformation);
            // key 与给定的密钥内容相关联的密钥算法的名称
            SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(), transformation);
            //Cipher 的操作模式,加密模式：ENCRYPT_MODE、 解密模式：DECRYPT_MODE、包装模式：WRAP_MODE 或 解包装：UNWRAP_MODE）
            cipher.init(mode ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE, secretKeySpec);
            byte[] bytes = cipher.doFinal(mode ? text.getBytes(StandardCharsets.UTF_8) : Base64.decode(text));
            return mode ? Base64.encode(bytes) : new String(bytes);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException | InvalidKeyException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }

    }
}
```
> DES加密：j+tPzTH7ttEeK+FrJaLY8OwmOezdN8hF
解密：你好世界！！
AES加密：/+cq03JhyvrTIJyYvWwc2Dc/bFUBNKelKPSANnWgsAw=
解密：你好世界！！
Triple Des加密：j+tPzTH7ttEeK+FrJaLY8OwmOezdN8hF
解密：你好世界！！


##### 非对称加密的简单实现
> 公钥加密，也叫非对称（密钥）加密（public key encryption），属于通信科技下的网络安全二级学科，指的是由对应的一对唯一性密钥（即公开密钥和私有密钥）组成的加密方法。它解决了密钥的发布和管理问题，是商业密码的核心。在公钥加密体制中，没有公开的是私钥，公开的是公钥。常用的算法：

RSA、ElGamal、背包算法、Rabin(Rabin的加密法可以说是RSA方法的特例)、Diffie-Hellman (D-H) 密钥交换协议中的公钥加密算法、Elliptic Curve Cryptography（ECC,椭圆曲线加密算法）。

```
public class UnSymmetryTest {
    public static void main(String[] args) throws Exception {

        String text = "===你好世界===";
        String algorithm = "RSA";

        PublicKey publicKey = getPublicKey(algorithm, "/Users/a201/Downloads/publicKey.txt");
        PrivateKey privateKey = getPrivateKey(algorithm, "/Users/a201/Downloads/privateKey.txt");

        String s = RSAEncrypt(text, algorithm, publicKey);
        String s1 = RSADecrypt(s, algorithm, privateKey);

        System.out.println(s);
        System.out.println(s1);

//        generateKeyFile("RSA","/Users/a201/Downloads/privateKey.txt","/Users/a201/Downloads/publicKey.txt");

    }

    /**
     * 获取公钥,key
     * @param algorithm  算法
     * @param publicPath 密匙文件路径
     * @return
     */
    private static PublicKey getPublicKey(String algorithm, String publicPath) throws IOException, NoSuchAlgorithmException, Base64DecodingException, InvalidKeySpecException {
        String publicEncodeString = FileUtils.readFileToString(new File(publicPath), StandardCharsets.UTF_8);
        //返回转换指定算法的 public/private 关键字的 KeyFactory 对象。
        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
        //此类表示根据 ASN.1 类型 SubjectPublicKeyInfo 进行编码的公用密钥的 ASN.1 编码
        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(Base64.decode(publicEncodeString));
        return keyFactory.generatePublic(x509EncodedKeySpec);
    }

    /**
     * 获取私钥，key
     * @param algorithm   算法
     * @param privatePath 密匙文件路径
     * @return
     */
    private static PrivateKey getPrivateKey(String algorithm, String privatePath) throws IOException, NoSuchAlgorithmException, Base64DecodingException, InvalidKeySpecException {
        String privateEncodeString = FileUtils.readFileToString(new File(privatePath), StandardCharsets.UTF_8);
        //返回转换指定算法的 public/private 关键字的 KeyFactory 对象。
        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
        //创建私钥key的规则  此类表示按照 ASN.1 类型 PrivateKeyInfo 进行编码的专用密钥的 ASN.1 编码
        PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(Base64.decode(privateEncodeString));
        //私钥对象
        return keyFactory.generatePrivate(pkcs8EncodedKeySpec);
    }

    /**
     * 加密
     * @param text      明文
     * @param algorithm 算法
     * @param key       私钥/密钥
     * @return 密文
     */
    private static String RSAEncrypt(String text, String algorithm, Key key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchProviderException {
        Cipher cipher = Cipher.getInstance(algorithm);
        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] bytes = cipher.doFinal(text.getBytes(StandardCharsets.UTF_8));
        return Base64.encode(bytes);
    }

    /**
     * 解密
     * @param extracted 密文
     * @param algorithm 算法
     * @param key       密钥/私钥
     * @return String 明文
     */
    private static String RSADecrypt(String extracted, String algorithm, Key key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, Base64DecodingException, NoSuchProviderException {
        Cipher cipher = Cipher.getInstance(algorithm);
        cipher.init(Cipher.DECRYPT_MODE, key);
        byte[] bytes1 = cipher.doFinal(Base64.decode(extracted));
        return new String(bytes1);
    }

    /**
     * 生成公钥和私钥文件
     * @param algorithm   算法
     * @param privatePath 私钥路径
     * @param publicPath  公钥路径
     */
    private static void generateKeyFile(String algorithm, String privatePath, String publicPath) throws NoSuchAlgorithmException, IOException {
        //返回生成指定算法的 public/private 密钥对的 KeyPairGenerator 对象
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);
        //生成一个密钥对
        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        //私钥
        PrivateKey privateKey = keyPair.getPrivate();
        //公钥
        PublicKey publicKey = keyPair.getPublic();

        byte[] privateKeyEncoded = privateKey.getEncoded();
        byte[] publicKeyEncoded = publicKey.getEncoded();

        String privateEncodeString = Base64.encode(privateKeyEncoded);
        String publicEncodeString = Base64.encode(publicKeyEncoded);
        //需导入commons-io
        FileUtils.writeStringToFile(new File(privatePath), privateEncodeString, StandardCharsets.UTF_8);
        FileUtils.writeStringToFile(new File(publicPath), publicEncodeString, StandardCharsets.UTF_8);
    }
}
```

##### 非对称解密的简单实现
```
public class HybridEncryptionTest {

    public static void main(String[] args) {
        // 测试数据
        String text = "[{\"account_set_code\":\"GSTHXCXGJJGYXGS\",\"account_set_name\":\"甘肃通汇鑫成型钢筋加工有限公司\",\"amount\":-8019030.45,\"audit_status\":\"new\",\"create_time\":1675928668000,\"creator_name\":\"系统管理员\",\"customer\":\"甘肃通汇鑫成型钢筋加工有限公司\",\"customer_code\":\"GSTHXCXGJJGYXGS\",\"fee_code\":\"HTJC\",\"fee_name\":\"合同价差\",\"fee_no\":\"CGFYD00015\",\"fee_type\":\"other_fee\",\"invoice_type\":\"增值税专用发票（0.13）\",\"op_type\":\"update\",\"order_source\":\"ERP-GSTHXCXGJJGYXGS\",\"original_remark\":\"\",\"receipt_or_pay\":\"receipt\",\"settle_customer\":\"甘肃通汇鑫成型钢筋加工有限公司\",\"settle_customer_code\":\"GSTHXCXGJJGYXGS\",\"settle_mode\":\"内部转账\",\"tax_rate\":13.00,\"time_stamp\":\"1675931247605\",\"unit_price\":5000}]";
        System.out.println("原始数据: "+text+'\n');

        // 算法
        String transformation = "AES";
        // 随机密钥
        String randomKey = extracted(transformation);
        System.out.println("AES随机key: "+randomKey+'\n');

        // 使用随机 key 对数据 对称加密
        String symmetryData = extracted(text, randomKey, transformation, true);
        System.out.println("AES加密：" + symmetryData+'\n');
        String extracted3 = extracted(symmetryData, randomKey, transformation, false);
        System.out.println("AES解密：" + extracted3+'\n');

        PublicKey rsa = null;
        try {
            // 公钥应提前由接收方生成给发送方
            rsa = getPublicKey("RSA", "/Users/a201/Downloads/publicKey.txt");
        } catch (IOException | NoSuchAlgorithmException | Base64DecodingException | InvalidKeySpecException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        // 对随机 key 使用非对称加密

        String rsaKey = "";
        try {
            rsaKey = RSAEncrypt(randomKey, "RSA", rsa);
            System.out.println("RSA加密后:" + rsaKey+'\n');
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException |
                 BadPaddingException | NoSuchProviderException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }


        PrivateKey privateKey = null;
        // 解密
        // 1、使用RSA解密 key
        try {
            privateKey = getPrivateKey("RSA", "/Users/a201/Downloads/privateKey.txt");
        } catch (IOException | NoSuchAlgorithmException | Base64DecodingException | InvalidKeySpecException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }

        // 获取解密后的  randomKey
        String unRsaKey = "";
        try {
            unRsaKey = RSADecrypt(rsaKey, "RSA", privateKey);
            System.out.println("RSA解密后:" + unRsaKey +'\n');
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException |
                 BadPaddingException | Base64DecodingException | NoSuchProviderException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }

        // 2、使用 解密后的 key 对对称加密数据解密
        String originalData = extracted(symmetryData, unRsaKey, transformation, false);
        System.out.println("AES解密后的原始数据:" + originalData+'\n');


    }

    /**
     * 生成随机的AES密钥
     * @param transformation 加密算法
     * @return
     */
    private static String extracted(String transformation){
        // 生成随机的AES密钥
        KeyGenerator aesKeyGen = null;
        try {
            aesKeyGen = KeyGenerator.getInstance(transformation);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        aesKeyGen.init(128);
        SecretKey aesKey = aesKeyGen.generateKey();
        return Base64.encode(aesKey.getEncoded());
    }

    /**
     *  对称加密
     * @param text           明文/base64密文
     * @param key            密钥
     * @param transformation 转换方式
     * @param mode           加密/解密
     */
    private static String extracted(String text, String key, String transformation, boolean mode){
        Cipher cipher = null;
        try {
            cipher = Cipher.getInstance(transformation);
            // key 与给定的密钥内容相关联的密钥算法的名称
            SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(), transformation);
            //Cipher 的操作模式,加密模式：ENCRYPT_MODE、 解密模式：DECRYPT_MODE、包装模式：WRAP_MODE 或 解包装：UNWRAP_MODE）
            cipher.init(mode ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE, secretKeySpec);
            byte[] bytes = cipher.doFinal(mode ? text.getBytes(StandardCharsets.UTF_8) : Base64.decode(text));
            return mode ? Base64.encode(bytes) : new String(bytes);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException | InvalidKeyException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }


    /**
     * 获取公钥,key
     * @param algorithm  算法
     * @param publicPath 密匙文件路径
     * @return
     */
    private static PublicKey getPublicKey(String algorithm, String publicPath) throws IOException, NoSuchAlgorithmException, Base64DecodingException, InvalidKeySpecException {
        String publicEncodeString = FileUtils.readFileToString(new File(publicPath), StandardCharsets.UTF_8);
        //返回转换指定算法的 public/private 关键字的 KeyFactory 对象。
        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
        //此类表示根据 ASN.1 类型 SubjectPublicKeyInfo 进行编码的公用密钥的 ASN.1 编码
        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(com.sun.org.apache.xml.internal.security.utils.Base64.decode(publicEncodeString));
        return keyFactory.generatePublic(x509EncodedKeySpec);
    }

    /**
     * 获取私钥，key
     * @param algorithm   算法
     * @param privatePath 密匙文件路径
     * @return
     */
    private static PrivateKey getPrivateKey(String algorithm, String privatePath) throws IOException, NoSuchAlgorithmException, Base64DecodingException, InvalidKeySpecException {
        String privateEncodeString = FileUtils.readFileToString(new File(privatePath), StandardCharsets.UTF_8);
        //返回转换指定算法的 public/private 关键字的 KeyFactory 对象。
        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
        //创建私钥key的规则  此类表示按照 ASN.1 类型 PrivateKeyInfo 进行编码的专用密钥的 ASN.1 编码
        PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(com.sun.org.apache.xml.internal.security.utils.Base64.decode(privateEncodeString));
        //私钥对象
        return keyFactory.generatePrivate(pkcs8EncodedKeySpec);
    }


    /**
     * 非对称加密
     * @param text      明文
     * @param algorithm 算法
     * @param key       私钥/密钥
     * @return 密文
     */
    private static String RSAEncrypt(String text, String algorithm, Key key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchProviderException {
        Cipher cipher = Cipher.getInstance(algorithm);
        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] bytes = cipher.doFinal(text.getBytes(StandardCharsets.UTF_8));
        return com.sun.org.apache.xml.internal.security.utils.Base64.encode(bytes);
    }

    /**
     * 非对称解密
     * @param extracted 密文
     * @param algorithm 算法
     * @param key       密钥/私钥
     * @return String 明文
     */
    private static String RSADecrypt(String extracted, String algorithm, Key key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, Base64DecodingException, NoSuchProviderException {
        Cipher cipher = Cipher.getInstance(algorithm);
        cipher.init(Cipher.DECRYPT_MODE, key);
        byte[] bytes1 = cipher.doFinal(com.sun.org.apache.xml.internal.security.utils.Base64.decode(extracted));
        return new String(bytes1);
    }
}
```
##### 打印的数据
> 原始数据:   [{"account_set_code":"GSTHXCXGJJGYXGS","account_set_name":"甘肃通汇鑫成型钢筋加工有限公司","amount":-8019030.45,"audit_status":"new","create_time":1675928668000,"creator_name":"系统管理员","customer":"甘肃通汇鑫成型钢筋加工有限公司","customer_code":"GSTHXCXGJJGYXGS","fee_code":"HTJC","fee_name":"合同价差","fee_no":"CGFYD00015","fee_type":"other_fee","invoice_type":"增值税专用发票（0.13）","op_type":"update","order_source":"ERP-GSTHXCXGJJGYXGS","original_remark":"","receipt_or_pay":"receipt","settle_customer":"甘肃通汇鑫成型钢筋加工有限公司","settle_customer_code":"GSTHXCXGJJGYXGS","settle_mode":"内部转账","tax_rate":13.00,"time_stamp":"1675931247605","unit_price":5000}]

> AES随机key: K3wLrOsjDKamI27s93g+Pw==

> AES加密：so/QnwwVVr0pIiuZBzI24Yew/fxhvtIZmwCCrugbFo+VqROocE2TU0OciHRlJ50BWIfa/4spl15l7GLAxuPTgIg1jSeWC/NlCUskh+Xl76SEzR4T0wNYiZI7a1FtFSCP5sJHsZNCiQK3jw3oM2ytIBbFzh7N3sVQdQK/CnAiUCx0swEM+dNTyS8JFsGoighmf6JIEqtQkd3Gjqs3TbC1QODH5sXjT0Z7R/aI6IBzzvtn0O06kAVdsntkM2TX1eNWXYeivITprZJSFJFySPQtm2ILxuRhAHwSCd0QyHW5YZcPRsJT3tz9kRGDOE5cGcPf6UV3VPQ8N1cz/9A1PeAt86V5XrKKhw90AZ4jL8dTG4uITKtVGyA6Ecasx6NI3zs5Qg0ofY9mYEehORB1TOdtn2kbZCvvqX0gP7jy1NqCFKf/gp4x1dKij7CM87WI+pY+gQDjZ3gU64+NZrFuyHwvlEymxuHNUwjQonkNlKg5RtqKWCqAzeWFxm8sKEyB/xrhM+/4IdBUBstBN0IcIOmiVl0uS51py5U9QbbDtq5QwZwGgaMGX1yPikNpSgLnVWWGdZR398rtobw0Qwo1WP5bHAjp/MhViTZCr6JJdolvgdxBu0ymA8mrIu+hHc30mlnjDmYjsAmJMqG72xzV6Pf+gOgHbEj6xx3YsiJWJvPb3kMhsm28Nav3LjAp98E4n1im3YEI6lktKA3t/hFB5/QZpQECM/do87ya0YkFtXVoUS45qMz2EZD8xjO4AtAQiWqfcTRacfVcyT9w7IZWZg6MQM5XVJs6wLoLEg/go++XS3iJ6W6fwLU8pweMxI/w6+uv7tXnG3R/v2QYZOe3OC0Cglhyunm0437l0hmhLq/6kGCgxp6GRH9vKiVBQDQUmVknUrHLMlT9WAz5DPDLxfBmOtiemCpT5hd1Qc5YXtuv2ltesX9lys9QxiwDezkaP9gr7rqK48HTUey7ThTJqEwt/yTkoeDDMnT0dWN5nEo3f14=

> AES解密：[{"account_set_code":"GSTHXCXGJJGYXGS","account_set_name":"甘肃通汇鑫成型钢筋加工有限公司","amount":-8019030.45,"audit_status":"new","create_time":1675928668000,"creator_name":"系统管理员","customer":"甘肃通汇鑫成型钢筋加工有限公司","customer_code":"GSTHXCXGJJGYXGS","fee_code":"HTJC","fee_name":"合同价差","fee_no":"CGFYD00015","fee_type":"other_fee","invoice_type":"增值税专用发票（0.13）","op_type":"update","order_source":"ERP-GSTHXCXGJJGYXGS","original_remark":"","receipt_or_pay":"receipt","settle_customer":"甘肃通汇鑫成型钢筋加工有限公司","settle_customer_code":"GSTHXCXGJJGYXGS","settle_mode":"内部转账","tax_rate":13.00,"time_stamp":"1675931247605","unit_price":5000}]

> RSA加密后:Xx+wR6dDKiSPWjmLHKQxb14Brw62V7XtJKqTA1QREm5sttwKFFqNvlkCt5lvYb4uHCTfkxVhn89R
iLiQORnQgkDNTAZLCgMsiv+cLhQrNLp05mBvWGF/CdMeFsomlCDrxaqPsdV6HKLYM4Meyl5K02mW
QTBWnHL7txsff5rdr+BgfxOz+i6VsFGhAcWsD70LAtNIjRHYOT+AKSCNTEcp9rLhcqBYfemwWCgd
bE0fCqje2PYAg/BTAuzhSPNbLCTT9KlTFTNO0T9dI+v1kSMYK5vs0MnEqx/akqbweEl6jeMIEWcK
2vMs7z9J6N/TyyWPlb4yFnsss9f6HtWgveyUEA==

> RSA解密后:K3wLrOsjDKamI27s93g+Pw==

> AES解密后的原始数据:[{"account_set_code":"GSTHXCXGJJGYXGS","account_set_name":"甘肃通汇鑫成型钢筋加工有限公司","amount":-8019030.45,"audit_status":"new","create_time":1675928668000,"creator_name":"系统管理员","customer":"甘肃通汇鑫成型钢筋加工有限公司","customer_code":"GSTHXCXGJJGYXGS","fee_code":"HTJC","fee_name":"合同价差","fee_no":"CGFYD00015","fee_type":"other_fee","invoice_type":"增值税专用发票（0.13）","op_type":"update","order_source":"ERP-GSTHXCXGJJGYXGS","original_remark":"","receipt_or_pay":"receipt","settle_customer":"甘肃通汇鑫成型钢筋加工有限公司","settle_customer_code":"GSTHXCXGJJGYXGS","settle_mode":"内部转账","tax_rate":13.00,"time_stamp":"1675931247605","unit_price":5000}]

---
##### 最后
[怎么设计大文件、大数据场景下的传输加密方案] https://www.cnblogs.com/xiaoxi-jinchen/p/17167910.html

[保证接口数据安全的10种方式] https://juejin.cn/post/7116520783534522399